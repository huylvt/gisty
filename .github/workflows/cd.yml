name: CD

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/gisty
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/gisty-web

jobs:
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get short SHA
        id: sha
        run: echo "short=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ steps.sha.outputs.short }}
            ${{ env.BACKEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./web
          file: ./web/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ steps.sha.outputs.short }}
            ${{ env.FRONTEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_API_URL=${{ secrets.API_URL }}

    outputs:
      image_tag: ${{ steps.sha.outputs.short }}

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment files
        run: |
          mkdir -p deploy

          # Create .env file from secrets
          cat << EOF > deploy/.env
          # Server
          PORT=8080
          ENV=production
          APP_URL=${{ secrets.APP_URL }}

          # MongoDB
          MONGO_URI=${{ secrets.MONGO_URI }}
          MONGO_DB=${{ secrets.MONGO_DB }}
          MONGO_USERNAME=${{ secrets.MONGO_USERNAME }}
          MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}

          # Redis
          REDIS_URI=${{ secrets.REDIS_URI }}

          # S3
          S3_ACCESS_KEY_ID=${{ secrets.S3_ACCESS_KEY_ID }}
          S3_SECRET_ACCESS_KEY=${{ secrets.S3_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
          S3_REGION=${{ secrets.S3_REGION }}
          S3_ENDPOINT=${{ secrets.S3_ENDPOINT }}

          # Rate Limiting
          RATE_LIMIT_REQUESTS_PER_MINUTE=60
          RATE_LIMIT_ENABLED=true

          # Cleanup
          CLEANUP_INTERVAL=5m
          CLEANUP_BATCH_SIZE=100

          # Docker images
          BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}:${{ needs.build-and-push.outputs.image_tag }}
          FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}:${{ needs.build-and-push.outputs.image_tag }}
          EOF

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          source: "deploy/.env,docker-compose.prod.yml,nginx/"
          target: "/srv/gisty"
          strip_components: 0

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            cd /srv/gisty

            # Login to Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

            # Pull latest images
            docker compose -f docker-compose.prod.yml --env-file deploy/.env pull

            # Deploy with zero downtime
            docker compose -f docker-compose.prod.yml --env-file deploy/.env up -d --remove-orphans

            # Wait for services to be ready
            echo "Waiting for services to start..."
            sleep 15

            # Check container status
            echo "=== Container Status ==="
            docker compose -f docker-compose.prod.yml ps

            # Show logs if backend is not healthy
            echo "=== Backend Logs (last 50 lines) ==="
            docker logs gisty-app --tail 50 2>&1 || true

            # Verify deployment with retries
            echo "=== Health Check ==="
            for i in 1 2 3 4 5; do
              if docker exec gisty-app wget -qO- http://localhost:8080/health; then
                echo ""
                echo "Health check passed!"
                break
              fi
              echo "Attempt $i failed, waiting 5s..."
              sleep 5
            done

            # Final check
            docker exec gisty-app wget -qO- http://localhost:8080/health || {
              echo "=== Full Backend Logs ==="
              docker logs gisty-app 2>&1
              exit 1
            }

            # Cleanup old images
            docker image prune -af --filter "until=24h"

            echo "Deployment successful!"

      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ Deployment failed! Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.'
            })

  cleanup-dockerhub:
    name: Cleanup Old Docker Hub Images
    runs-on: ubuntu-latest
    needs: deploy
    if: success()

    steps:
      - name: Delete old backend images
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');

            const username = '${{ secrets.DOCKERHUB_USERNAME }}';
            const token = '${{ secrets.DOCKERHUB_TOKEN }}';
            const currentTag = '${{ needs.build-and-push.outputs.image_tag }}';
            const repos = ['gisty', 'gisty-web'];
            const keepTags = ['latest', currentTag];

            async function request(options, postData = null) {
              return new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      resolve({ status: res.statusCode, data: data ? JSON.parse(data) : null });
                    } catch (e) {
                      resolve({ status: res.statusCode, data: null });
                    }
                  });
                });
                req.on('error', reject);
                if (postData) req.write(postData);
                req.end();
              });
            }

            // Get JWT token
            const authResp = await request({
              hostname: 'hub.docker.com',
              path: '/v2/users/login/',
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            }, JSON.stringify({ username, password: token }));

            if (authResp.status !== 200) {
              console.log('Failed to authenticate with Docker Hub');
              return;
            }

            const jwt = authResp.data.token;

            for (const repo of repos) {
              console.log(`\nProcessing ${username}/${repo}...`);

              // Get all tags
              const tagsResp = await request({
                hostname: 'hub.docker.com',
                path: `/v2/repositories/${username}/${repo}/tags?page_size=100`,
                method: 'GET',
                headers: { 'Authorization': `Bearer ${jwt}` }
              });

              if (tagsResp.status !== 200 || !tagsResp.data.results) {
                console.log(`Failed to get tags for ${repo}`);
                continue;
              }

              const tags = tagsResp.data.results;
              console.log(`Found ${tags.length} tags`);

              // Delete old tags (keep latest and current)
              for (const tag of tags) {
                if (keepTags.includes(tag.name)) {
                  console.log(`Keeping: ${tag.name}`);
                  continue;
                }

                console.log(`Deleting: ${tag.name}`);
                const deleteResp = await request({
                  hostname: 'hub.docker.com',
                  path: `/v2/repositories/${username}/${repo}/tags/${tag.name}/`,
                  method: 'DELETE',
                  headers: { 'Authorization': `Bearer ${jwt}` }
                });

                if (deleteResp.status === 204) {
                  console.log(`  ✓ Deleted ${tag.name}`);
                } else {
                  console.log(`  ✗ Failed to delete ${tag.name}: ${deleteResp.status}`);
                }
              }
            }

            console.log('\nCleanup completed!')
